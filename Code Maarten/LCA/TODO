
1. Split things up according to functionality and build separate libraries:
	- nucleus
	- pairs
	- ...
2. Clean up 
	- Nucleus::makepairs() (nucleus.cpp)
    - Nucleus::get_shell_max(...) (nucleus.cpp)

3. Make use of general 1d interpolator instead of 
   repeating heaps of code in speedy.cpp...


4. Reproduce the table with "norms" on page 97 of Maartens thesis.
   Make this into a exec file.

5. Clean up
    operator_virtual_ob::get_tensor_me(...)
    do something more elegant and clearer than all those if/else if/else statements

6. Check if the signs in the threejs in density_ob3.cpp really don't matter
   That is the ones that can be matched to corresponding threej of the form
   (*,*,*,0,0,0)

7. Do checks for nucleus with Z>A, now code runs happily without complaining

===========================================================
Wim
===========================================================

1. check partially filled shells functionality: Pair::setfnorm(factor) is referred to in manual

2. take out char* arguments and make them strings (RecMosh)

3. modify nucleusall such that bookkeeping is done of which pairs (or links) originate from which isospin combination

4. modify calculation of matrix elements such that all isospin combinations are being calculated in one go.
Now it is very inefficient as basically the program has to start from scratch each time and does almost the same thing all over (but with different linear combinations)

5. replace pointer arguments by reference where applicable...

6. Nucleus::nucleus get rid of dynamic allocations

7. storage of moshinskys: make binary, one file

8. recmosh files had a whole lot of numbers <10E-10, maybe put them zero

9. check what the sum is in the pair class [see nucleus.cpp::450], also [getSum in pair.h::100]
check what getRelPair returns [nucleus.cpp::675]

10. Nucleus::makepaircoeffs -> make sense of it  :: Partially done
Check how links are dealt with ("add" functions), now link is stored bidirectionally, but matrix elements aren't necessarily?

11. how does the norm for pairs work?  pair.getcoeff return sqrt of the norm (?)
in nucleus::makepairs it's also not clear to me the different cases (sometimes sqrt sometimes not)

12. shells class, remove pointers 

14. add sanity check to see that the recmosh object in pair & newcoef is for the correct quantum numbers.

16. why double pointers in Pair::getCoeff, make norm pointer a ref

17. recmosh output: in one instance a lot more zero elements  
What is stored in the Maprecmosh map (check indices).  How to deal with storing/readingin this in one file?
Strange issues when putting some (i thought) small values to zero (all output became zero in the files)
Something I don't understand yet: the recmosh files get extra zero valued entries once heavier nuclei are calculated (for instance the 0202.dat file when you reach Ag)
or the 0002.dat file when you go from Al to calculated

18. can the links be stored somehow for any nucleus?