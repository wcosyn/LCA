\documentclass[10pt]{article}

\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{braket}
\usepackage{todonotes}
\usepackage{bbold}

\begin{document}
\section{Momentum distributions}
\section{Second quantization}
This section will be somewhat over-elaborated. But it can serve as a recapitulation of second quantization.

The one body momentum distribution operator is defined as,
\begin{align}
	\hat{n}(p) = \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}}
\end{align}
It's action on a multi particle ground state $\ket{\Phi}$,
\begin{align}
	\braket{ \Phi | \hat{n}(p) | \Phi} = \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}} \braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi}
\end{align}
The creation and annihilation operators $a_{\mathbf{p}}^{\dagger}$,$a_{\mathbf{p}}$ have only meaning working on particles with definite momentum or the vacuum state $\ket{0}$.
\begin{align}
	\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \int \textrm{d}^{3} \mathbf{p}_{1} \ldots \textrm{d}^{3} \mathbf{p}_{A} \braket {\Phi | \mathbf{p}_1 \mathbf{p}_2 \ldots \mathbf{p}_{A}} \braket{ \mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p}_{A} | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi } \\
	&= \int \textrm{d}^{A} \mathbf{p}_{1} \ldots \textrm{d}^{3} \mathbf{p}_{A} \braket {\Phi | \mathbf{p}_1 \mathbf{p}_2 \ldots \mathbf{p}_{A}} \braket{ 0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots a_{\mathbf{p}_{A}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi } 
\end{align}
Using the anticommutation relation $\{ a_{\mathbf{p}} ,a_{\mathbf{q}}^{\dagger} \} = \delta(\mathbf{p}-\mathbf{q})$, we get
\begin{align}
	\braket{0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots a_{\mathbf{p}_{A}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &=
	\braket{0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots \delta(\mathbf{p}-\mathbf{p}_{A}) a_{\mathbf{p}} | \Phi} - \braket{0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots a_{\mathbf{p}_{A-1}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi} \\
	&= \delta(\mathbf{p}-\mathbf{p}_{A}) \braket{\mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p} | \Phi } - \delta(\mathbf{p}-\mathbf{p}_{A-1}) \braket{0 | a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A-2}} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi} \\
	&+ \braket{0| a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A-2}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_{A-1}} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi} \\
 &= \delta(\mathbf{p}-\mathbf{p}_{A}) \braket{\mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p}_{A} | \Phi } + \delta(\mathbf{p}-\mathbf{p}_{A-1}) \braket{\mathbf{p}_{1} \ldots \mathbf{p}_{A-2} \mathbf{p}_{A-1} \mathbf{p}_{A} | \Phi} \\
	&+ \braket{0| a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A-2}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_{A-1}} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi}
	&= \ldots \\
	&= \sum_{i=1}^{A} \delta(\mathbf{p} - \mathbf{p}_{i}) \braket{ \mathbf{p}_{1} \ldots \mathbf{p}_{A} | \Phi} + (-1)^{A} \underbrace{\braket{ 0 | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi}}_{=0}
\end{align}
Hence,
\begin{align}
	\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \int \textrm{d}^{3} \mathbf{p}_{1} \ldots \textrm{d}^{3} \mathbf{p}_{A} \braket {\Phi | \mathbf{p}_1 \mathbf{p}_2 \ldots \mathbf{p}_{A}} \sum_{i=1}^{A} \delta(\mathbf{p} - \mathbf{p}_{i}) \braket{ \mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p}_{A} | \Phi}
\end{align}
If $\ket{\Phi}$ is a slater determinant of orthonormal single particle wave functions $\ket{\phi_{\alpha_{i}}}$ we get,
\begin{align}
	\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \sum_{i=1}^{A} | \braket{ \mathbf{p} | \phi_{\alpha_{i}} } |^{2} = \sum_{i=1}^{A} \phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_i}(\mathbf{p})
\end{align}
Note that we also could have derived this result by instead of inserting the unit $\prod_{i=1}^{A} \textrm{d}^{3} \mathbf{p}_{i} \ket{\mathbf{p}_{i}}\bra{\mathbf{p}_{i}}$ we expand $\ket{\Phi}$ in terms of single particle creation operators,
\begin{align}
	a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} \ket{\Phi} &= a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} \ket{ \alpha_1 \alpha_2 \ldots \alpha_A } = a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \ldots a_{\alpha_A}^{\dagger} \ket{0}
\end{align}
The commutation relations between $a_{\mathbf{p}}$ and $a_{\alpha_i}$ are easily derived by expanding $a_{\alpha_i}$ in momentum creation operators,
\begin{align}
	a_{\alpha_i}^{\dagger} &= \int \textrm{d}^{3} \mathbf{k} \phi_{\alpha_i}(\mathbf{k}) a_{k}^{\dagger} \\
	\Rightarrow a_{\mathbf{p}} a_{\alpha_i}^{\dagger} &= \int \textrm{d}^{3} \mathbf{k} \phi_{\alpha_i}(\mathbf{k}) a_{\mathbf{p}} a_{\mathbf{k}}^{\dagger} = \phi_{\alpha_i}(\mathbf{p}) - a_{\alpha_i}^{\dagger} a_{\mathbf{p}}
\end{align}
So,
\begin{align}
	a_{\mathbf{p}} \ket{\Phi} &= a_{\mathbf{p}} a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \ldots a_{\alpha_A}^{\dagger} \ket{0} = (\phi_{\alpha_1}(\mathbf{p}) - a_{\alpha_1}^{\dagger} a_{\mathbf{p}}) a_{\alpha_2}^{\dagger} \ldots a_{\alpha_A}^{\dagger} \ket{0} \\
	&= \sum_{i=1}^{A} (-1)^{i-1} \phi_{\alpha_{i}}(\mathbf{p}) \ket{ \alpha_1 \ldots \alpha_{i-1} \alpha_{i+1} \ldots \alpha_A}
\end{align}
The conjugate gives,
\begin{align}
	\bra{\Phi} a_{\mathbf{p}}^{\dagger} &= \sum_{j=1}^{A} (-1)^{j-1} \bra{ \alpha_1 \ldots \alpha_{j-1} \alpha_{j+1} \ldots \alpha_A} \phi_{\alpha_j}^{\dagger}(\mathbf{p})
\end{align}
Hence,
\begin{align}
\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \sum_{i,j=1}^{A} (-1)^{i+j} \phi_{\alpha_j}^{\dagger}(\mathbf{p}) \phi_{\alpha_{i}}(\mathbf{p})  \underbrace{\braket{ \alpha_1 \ldots \alpha_{j-1} \alpha_{j+1} \ldots \alpha_A | \alpha_1 \ldots \alpha_{i-1} \alpha_{i+1} \ldots \alpha_A }}_{=\delta_{ij}} \\
	&= \sum_{i} \phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_{i}}(\mathbf{p})
\end{align}
Which is exactly the same result as before.



So the one body momentum distribution is given by,
\begin{align}
	\braket{ \Phi | \hat{n}(p) | \Phi} &=  \sum_{i=1}^{A} \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}}\phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_i}(\mathbf{p})
\end{align}
Note that this distribution is normed to the number of particles $A$. To get the momentum distribution normed to unity we have to divide by A,
\begin{align}
	\braket{ \Phi | \hat{n}(p) | \Phi} &=  \frac{1}{A} \sum_{i=1}^{A} \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}}\phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_i}(\mathbf{p})
\end{align}

\section{Nucleus}
\subsection{shell.h}
This class contains the quantum number of a shell $nlj$. It has two (proton \& neutron) static arrays containing all the shells.
\begin{verbatim}
	shellsN = [ Shell(n1,l1,j1), Shell(n2,l2,j2), ... ]
	shellsP = [ Shell(n1,l1,j1), Shell(n2,l2,j2), ... ]
\end{verbatim}
These two arrays are initialised and deleted by the static methods \texttt{Shell::initialiseShells}, \texttt{Shell::deleteShells}.

\subsection{nucleus.h}
First important method here is \texttt{Nucleus::makePairs}. Note that this relies on overloaded virtual functions to function. It iterates over the quantum numbers, $n_1 l_1 j_1 m_{j_1}, n_2 l_2 j_2 m_{j_2}$ and makes a pair for each of these combinations: \texttt{Pair::Pair(mosh,n1,l1,j1,mj1,t1,n2,l2,j2,mj2,t2)}. \texttt{mosh} is the return value of \texttt{RecMosh::createRecMosh(n1,l1,n2,l2,inputdir,outputdir)}, being a \texttt{RecMosh} object. The moshinsky brackets $\braket{n_1 l_1 n_2 l_2; \Lambda | n l N L ; \Lambda}$ can be accessed by calling \texttt{RecMosh::getCoefficient(n,l,N,L,Lambda)}.
Open shells are taken care of by calculating a open shell correction factor and applying it to the pair via \texttt{Pair::setfnorm(factor)}.

Once the pairs (\texttt{Pair::Pair}) are generated we can generate a 



\section{Pair coupling}
\subsection{pair.h}
This class represents the state
\begin{align}
	\ket{ \alpha_1, \alpha_2}_{\textrm{nas}} \;\;\;, \ket{\alpha} \equiv \ket{n l j m_j t m_t}
\end{align}
The class calculates all the coefficients,
\begin{align}
	C_{\alpha_1 \alpha_2}^{A} = \braket{A \equiv \{ n l S j m_j, N L M_L T M_T\} | \alpha_1 \alpha_2}
	\label{eq:coef}
\end{align}
The main method here is \texttt{Pair::makecoeflist()}. It loops over all possible values of $ A \equiv \{ S,T,n,l,N,M_L,j,m_j \}$. Where in the summation over $\{n,l,N,L\}$ the energy conservation $2n_1 + l_1 + 2n_2 + l_2 = 2n + l + 2N + L$ is taken into account to eliminate one of the summation loops, $L = 2n_1 + l_1 + 2n_2 + l_2 - 2n - l - 2N$. Note that $M_T$ is also fixed by $M_T = m_{t_1} + m_{t_2}$ and no summation over this is performed, as we want to keep the contribution from different pairs seperated.
For each $A$ a new object \texttt{Newcoef} is generated and stored in the member \texttt{std::vector<NewCoef*> coeflist}.
\subsection{newcoef.h}
This class takes the parameters $n_1 l_1 j_1 m_{j_1} m_{t_1} n_2 l_2 j_2 m_{j_2} m_{t_2} N L M_L n l S j m_j T M_T$, and calculates the coefficient given in Eq. (\ref{eq:coef}). It takes also a pointer to a \texttt{RecMosh} object that holds the Moshinsky brakets. The only function in this class is to calculate $C_{\alpha_1 \alpha_2}^{A}$ using the formula,
\begin{multline}
	\sum_{J M_J} \sum_{\Lambda} 
	[ 1 - (-1)^{L+S+T}] \braket{ t_1 m_{t_1} t_2 m_{t_2} | T M_T }
	\braket{ j_1 m_{j_1} j_2 m_{j_2} | J M_J}
	\braket{ j m_j L M_L | J M_J } \\
	\braket{ n l N L; \Lambda | n_1 l_1 n_2 l_2 ; \Lambda}_{\textrm{SMB}}
	\sqrt{2 \Lambda + 1} \sqrt{ 2j+1}
	\left\{
	\begin{array}{ccc}
		j & L & J \\
		\Lambda & S & l
	\end{array}
	\right\} \\
	\sqrt{2j_1 + 1} \sqrt{2j_2 + 1} \sqrt{ 2S + 1} \sqrt{ 2 \Lambda + 1}
	\left\{
	\begin{array}{ccc}
		l_1 & s_1 & j_1 \\
		l_2 & s_2 & j_2 \\
		\Lambda & S & J \\
	\end{array}
	\right\}
\end{multline}
It is easy to check that the result indeed depends on $\alpha_1, \alpha_2, A$. Note that it is always assumed that $s_i,t_i \equiv \frac{1}{2}$ as we are dealing with protons and neutrons.
This class also defines a \texttt{``key''} to be able to index the coefficients, \texttt{key = ``nlSjm\_j.NLM\_L.TM\_T''}.

\subsection{paircoef.h}
This is a very thin class designed to do some bookkeeping. As outlined in Maartens thesis pg 156, different $\ket{\alpha_1 \alpha_2}$ combinations will sometimes map to the same ``rcm'' states $A = \ket{ nlSjm_j NLM_L TM_T}$. In matrix element calculations,
\begin{align}
	\braket{\alpha_1 \alpha_2 | \hat{\mathcal{O}} | \alpha_1 \alpha_2} = \sum_{AB} C_{\alpha_1 \alpha_2}^{A \dagger} C_{\alpha_1 \alpha_2}^{B} \braket {A | \hat{\mathcal{O}} | B }
	\label{eq:rcm_nonzerodiag}
\end{align}
We want to calculate matrix elements as $\braket{ A | \hat{\mathcal{O}} | B}$ only once. $\ket{\alpha_1 \alpha_2}$ that map to the same $A,B$ states should lookup the earlier calculated values for $\braket{ A | \hat{\mathcal{O}} | B}$.
In general the matrix element $\braket{ A | \hat{\mathcal{O}} | B }$ is not diagonal. 
A \texttt{Paircoef} object has all the quantum numbers in a rcm state $A$. In addition it holds a value and a map \texttt{ std::map<Paircoef*, double>}. The map is used to link a rcm state $\ket{A}$ to all other rcm states $\ket{B}$ which yield a non zero contribution for $\braket{ A | \hat{\mathcal{O}} | B }$. The value for the transformation coefficients $C_{\alpha_1,\alpha_2}^{A,\dagger} C_{\alpha_1,\alpha_2}^{B}$ is stored in the second field of the map (\texttt{double}). So that the the summation over $B$ (Eq. \ref{eq:rcm_nonzerodiag}) is replaced by,
\begin{align}
	\braket{\alpha_1 \alpha_2 | \hat{\mathcal{O}} | \alpha_1 \alpha_2} = \sum_{A} \sum_{\texttt{Paircoef(A).links}}  \texttt{link.strength} \braket {A | \hat{\mathcal{O}} | B }
\end{align}
\todo[inline]{\texttt{Paircoef::add(double val)} adds \texttt{val} to private member \texttt{value} but as far as I can see this private member \texttt{value} is NEVER used!}

\section{Matrix Elements}
First some theory on the matrix elements. In the calculation of the norm we only have the correlation operator $\hat{\wr}$ between the bras and kets.
\begin{align*}
	\braket{ \alpha \beta |\hat{\wr}(\vec{x}_{1},\vec{x}_{2}) + \hat{\wr}^{\dagger}(\vec{x}_{1},\vec{x}_{2}) + \hat{\wr}^{\dagger}(\vec{x}_{1},\vec{x}_{2})\hat{\wr}(\vec{x}_{1},\vec{x}_{2}) | \alpha \beta}
\end{align*}
$\hat{\wr}$ contains a central, tensor and spin-isospin part,
\begin{align*}
	\hat{\wr}(\vec{x}_{1},\vec{x}_{2}) = -f_c(r_{12}) + f_{t\tau}(r_{12}) \hat{S}_{12} \hat{\vec{\tau}}_{1} \cdot \hat{\vec{\tau}}_{2} + f_{\sigma \tau}(r_{12}) \hat{ \vec{\sigma}}_{1} \cdot \hat{ \vec{\sigma}}_{2} \hat{ \vec{\tau}}_{1} \cdot \hat{ \vec{\tau}}_{2}  \, .
\end{align*}
Transforming to the c.m. and relative coordinates a general matrix-element term can be written as,
\begin{align*}
	\braket{ n (l S) j m_j N L M_L T M_T |  \hat{\mathcal{O}}^{p\dagger} f^{\dagger}_{p} f_{q} \hat{\mathcal{O}}^{q} | n' (l' S') j' m_j' N' L' M_L' T' M_T'} 
\end{align*}
With $f_{p,q} \in \{ 1, f_{c}, f_{t\tau}, f_{\sigma \tau} \}$ and $\hat{\mathcal{O}}^{p,q}$ the corresponding operator $\in \{ \mathbb{1}, \mathbb{1},  \hat{S}_{12} \hat{\vec{\tau}}_{1} \cdot \hat{\vec{\tau}}_{2}, \hat{ \vec{\sigma}}_{1} \cdot \hat{ \vec{\sigma}}_{2} \hat{ \vec{\tau}}_{1} \cdot \hat{ \vec{\tau}}_{2} \} $.
As no operators act on the c.m. part $ \ket{ N L M_L}$ here we have,
\begin{align*}
	\delta_{NN'} \delta_{LL'} \delta_{M_L M_L'} \braket{ n (l S) j m_j T M_T |  \hat{\mathcal{O}}^{p\dagger} f^{\dagger}_{p} f_{q} \hat{\mathcal{O}}^{q} | n' (l' S') j' m_j' T' M_T'}  
\end{align*}

\section{Matrix elements bis}

Let us take a look at
\begin{align*}
	\braket{ S | \hat{ \vec{\sigma}}_{1} \cdot \hat{ \vec{\sigma}}_{2} | S'} = 4 \braket{ S | \hat{ \vec{s}}_{1} \cdot \hat{ \vec{s}}_{2} | S'} = 4 \braket{ S | \hat{\vec{S}}^{\, 2} - \hat{\vec{s}}_{1}^{\,2} - \hat{\vec{s}}_{2}^{\,2} | S'} = 2 ( S(S+1) - \frac{3}{4} - \frac{3}{4} ) \delta_{SS'} = \delta_{SS'} (2 S(S+1) - 3)
\end{align*}
As we have 2 spin $1/2$ particles S can be either $0,1$ resulting in $\braket{ 1 | \hat{ \vec{\sigma}}_{1} \cdot \hat{ \vec{\sigma}}_{2} | 1} = 1$, $\braket{ 0 | \hat{ \vec{\sigma}}_{1} \cdot \hat{ \vec{\sigma}}_{2} | 0} = -3$.
\todo[inline]{ Note that in the Maartens code the expression is modified to $4S-3$, which is equivalent for $S \in \{0,1\} $.}
Exactly the same derivation can be made for $\hat{\vec{\tau}}_{1} \cdot \hat{\vec{\tau}}_{2}$ leading to the same result.

\subsection{norm\_ob : public operator\_virtual\_ob}
Here we take a look at the calculation of the norm $\mathcal{N}$ in \texttt{norm\_ob.cpp}.
Note that this class inherits from \texttt{operator\_virtual\_ob}, declaring general one body member functions.
\begin{itemize}
	\item \texttt{norm\_ob::get\_me( Pair )}.
		This calculates the matrix element \textbf{meanfield} matrix element sum 
		\begin{enumerate}
		\item $\frac{2}{A} \sum_{ A B } C_{\alpha_1 \alpha_2}^{A \dagger} C_{\alpha_1 \alpha_2}^{B} \braket {A | B }$ for a pp and/or nn pair(s) (isospin $M_T = \pm 1$)
		\item $\frac{1}{A} \sum_{ A B} C_{\alpha_1 \alpha_2}^{A \dagger} C_{\alpha_1 \alpha_2}^{B} \braket {A | B }$ for a pn pair (isospin $M_T = 0$)
	\end{enumerate}
	for a specific pair $\alpha_1 \alpha_2$ passed trough \texttt{Pair}.
	\todo[inline]{For now I have no clue why/how the factor $\frac{2}{A}$($\frac{1}{A}$) in front of $\sum_{ A B } C_{\alpha_1 \alpha_2}^{A \dagger} C_{\alpha_1 \alpha_2}^{B} \braket {A | B }$ ...}		
		It is possible to filter on relative quantum numbers on $n_A,l_A,n_B,l_B$, selecting specific contributions \texttt{nAs,lAs,nBs,lBs} to the sum. A value of $-1$ for these variables is interpreted as ``all values allowed''. Trough the braket $\braket{ A | B }$ we already have $n_A = n_B := n$, $l_A = l_B := l$.
		\begin{itemize}
			\item \texttt{if (nAs > -1 \&\& nBs > -1)}
				This forces $\texttt{nAs} = \texttt{nBs} = n$. So for $\texttt{nAs} \neq \texttt{nBs}$ we will get $0$.
			\item \texttt{if (nAs == -1 \&\& nBs > -1)}
				This forces $\texttt{nBs} = n$. Selecting a specific $n = n_A = n_B$ contribution.
			\item \texttt{if (nAs > -1 \&\& nBs == -1)}
				This forces $\texttt{nAs} = n$. Selecting a specific $n = n_A = n_B$ contribution.
			\item \texttt{if (nAs == -1 \&\& nBs == -1)}
				This makes no restrictions on $n = n_A = n_B$.
		\end{itemize}
		The exact same is valid for $l = l_A = l_B$ and \texttt{lAs},\texttt{lBs}.
		A few examples (\texttt{nAs,lAs,nBs,lBs}):
		\begin{itemize}
			\item (\texttt{-1, 2,-1,-1}) : allow all $n = n_A = n_B$ values. Restriction on $l = l_A = l_B = \texttt{2}$.
			\item (\texttt{-1, 2,-1, 2}) : allow all $n = n_A = n_B$ values. Restriction on $l = l_A = l_B = \texttt{2}$.
		\end{itemize}
	As the unrestricted sum $\sum_{ A B } C_{\alpha_1 \alpha_2}^{A \dagger} C_{\alpha_1 \alpha_2}^{B} \braket {A | B } = \sum_{A} | C^{A}_{\alpha_1 \alpha_2}|^{2} $ equals 1, the return value of \texttt{get\_me} (for the unrestricted sum) is,
	\begin{itemize}
		\item $\frac{2}{A}$ with no restriction on the isospin ( \texttt{norm\_ob::norm\_ob\_params.t = 0})
		\item $\frac{2}{A}$ for pp-pairs, $\frac{1}{A}$ for pn-pairs and $0$ for nn-pairs for a proton (\texttt{norm\_ob::norm\_ob\_params.t~=~1})
		\item $0$ for pp-pairs, $\frac{1}{A}$ for pn-pairs and $\frac{2}{A}$ for nn-pairs for a neutron (\texttt{norm\_ob::norm\_ob\_params.t~=-1})
	\end{itemize}
	If we sum over all the pairs $ \sum_{\texttt{pair in pairs}} $ \texttt{norm::ob\_get\_me(pair,...)} we get,
	\begin{itemize}
		\item $\frac{A(A-1)}{2} \frac{2}{A} = A-1$ with no restriction on the isospin ( \texttt{norm\_ob::norm\_ob\_params.t~=~0})
		\item $\frac{Z(Z-1)}{2}\frac{2}{A} + NZ \frac{1}{A} + \frac{N(N-1)}{2} 0 = Z \frac{A-1}{A}$ for a proton (\texttt{norm\_ob::norm\_ob\_params.t~=~1})
		\item $\frac{Z(Z-1)}{2}0 + NZ \frac{1}{A} + \frac{N(N-1)}{2} \frac{2}{A} = N \frac{A-1}{A}$ for a neutron (\texttt{norm\_ob::norm\_ob\_params.t~=-1})
	\end{itemize}
	\todo[inline,caption={}]{
	\textbf{Open shellness not taken into account here. Must be done somewhere else (higher up)...} \\	
	For closed shell nuclei everything seems fine. For open shells however we get some strange results. For example $^{27}$Al with $13$ protons and $14$ neutrons has an open $1d\frac{5}{2}$ proton shell. Open-shell nuclei are treated as closed shell but the pairs in the open shells get a weight factor. This weight factor however is \textbf{not} present in the method \texttt{norm::ob\_get\_me(pair,...)}. Hence as $A = 27$ but the closed shell equivalent with $A=28$ causes the number of pairs to be $28\cdot 27 /2$ instead of $ 27 \cdot 26 /2$. We get
	\begin{itemize}
	\item $ \frac{ 28 \cdot 27}{2} \frac{2}{27} = 28$ ( \texttt{norm\_ob::norm\_ob\_params.t = 0}) 
	\item $ \frac{ 14 \cdot 13}{2} \frac{2}{27} + \frac{14 \cdot 14 }{27} = \frac{378}{27} = 14 $ (\texttt{norm\_ob::norm\_ob\_params.t~=~1}) \\
	\item $ \frac{14 \cdot 14 }{27} + \frac{ 14 \cdot 13}{2} \frac{2}{27} = \frac{378}{27} = 14 $ (\texttt{norm\_ob::norm\_ob\_params.t~=-~1}) \\
	\end{itemize}
	}
	\item \texttt{norm\_ob::get\_me\_corr\_right( Pair )}.
\end{itemize}

\end{document}
