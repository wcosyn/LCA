\documentclass[10pt]{article}

\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{braket}
\usepackage{todonotes}

\begin{document}
\section{Momentum distributions}
\section{Second quantization}
This section will be somewhat over-elaborated. But it can serve as a recapitulation of second quantization.

The one body momentum distribution operator is defined as,
\begin{align}
	\hat{n}(p) = \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}}
\end{align}
It's action on a multi particle ground state $\ket{\Phi}$,
\begin{align}
	\braket{ \Phi | \hat{n}(p) | \Phi} = \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}} \braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi}
\end{align}
The creation and annihilation operators $a_{\mathbf{p}}^{\dagger}$,$a_{\mathbf{p}}$ have only meaning working on particles with definite momentum or the vacuum state $\ket{0}$.
\begin{align}
	\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \int \textrm{d}^{3} \mathbf{p}_{1} \ldots \textrm{d}^{3} \mathbf{p}_{A} \braket {\Phi | \mathbf{p}_1 \mathbf{p}_2 \ldots \mathbf{p}_{A}} \braket{ \mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p}_{A} | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi } \\
	&= \int \textrm{d}^{A} \mathbf{p}_{1} \ldots \textrm{d}^{3} \mathbf{p}_{A} \braket {\Phi | \mathbf{p}_1 \mathbf{p}_2 \ldots \mathbf{p}_{A}} \braket{ 0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots a_{\mathbf{p}_{A}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi } 
\end{align}
Using the anticommutation relation $\{ a_{\mathbf{p}} ,a_{\mathbf{q}}^{\dagger} \} = \delta(\mathbf{p}-\mathbf{q})$, we get
\begin{align}
	\braket{0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots a_{\mathbf{p}_{A}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &=
	\braket{0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots \delta(\mathbf{p}-\mathbf{p}_{A}) a_{\mathbf{p}} | \Phi} - \braket{0 | a_{\mathbf{p}_{1}} a_{\mathbf{p}_{2}} \ldots a_{\mathbf{p}_{A-1}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi} \\
	&= \delta(\mathbf{p}-\mathbf{p}_{A}) \braket{\mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p} | \Phi } - \delta(\mathbf{p}-\mathbf{p}_{A-1}) \braket{0 | a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A-2}} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi} \\
	&+ \braket{0| a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A-2}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_{A-1}} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi} \\
 &= \delta(\mathbf{p}-\mathbf{p}_{A}) \braket{\mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p}_{A} | \Phi } + \delta(\mathbf{p}-\mathbf{p}_{A-1}) \braket{\mathbf{p}_{1} \ldots \mathbf{p}_{A-2} \mathbf{p}_{A-1} \mathbf{p}_{A} | \Phi} \\
	&+ \braket{0| a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A-2}} a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_{A-1}} a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi}
	&= \ldots \\
	&= \sum_{i=1}^{A} \delta(\mathbf{p} - \mathbf{p}_{i}) \braket{ \mathbf{p}_{1} \ldots \mathbf{p}_{A} | \Phi} + (-1)^{A} \underbrace{\braket{ 0 | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}_1} \ldots a_{\mathbf{p}_{A}} a_{\mathbf{p}} | \Phi}}_{=0}
\end{align}
Hence,
\begin{align}
	\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \int \textrm{d}^{3} \mathbf{p}_{1} \ldots \textrm{d}^{3} \mathbf{p}_{A} \braket {\Phi | \mathbf{p}_1 \mathbf{p}_2 \ldots \mathbf{p}_{A}} \sum_{i=1}^{A} \delta(\mathbf{p} - \mathbf{p}_{i}) \braket{ \mathbf{p}_{1} \mathbf{p}_{2} \ldots \mathbf{p}_{A} | \Phi}
\end{align}
If $\ket{\Phi}$ is a slater determinant of orthonormal single particle wave functions $\ket{\phi_{\alpha_{i}}}$ we get,
\begin{align}
	\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \sum_{i=1}^{A} | \braket{ \mathbf{p} | \phi_{\alpha_{i}} } |^{2} = \sum_{i=1}^{A} \phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_i}(\mathbf{p})
\end{align}
Note that we also could have derived this result by instead of inserting the unit $\prod_{i=1}^{A} \textrm{d}^{3} \mathbf{p}_{i} \ket{\mathbf{p}_{i}}\bra{\mathbf{p}_{i}}$ we expand $\ket{\Phi}$ in terms of single particle creation operators,
\begin{align}
	a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} \ket{\Phi} &= a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} \ket{ \alpha_1 \alpha_2 \ldots \alpha_A } = a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \ldots a_{\alpha_A}^{\dagger} \ket{0}
\end{align}
The commutation relations between $a_{\mathbf{p}}$ and $a_{\alpha_i}$ are easily derived by expanding $a_{\alpha_i}$ in momentum creation operators,
\begin{align}
	a_{\alpha_i}^{\dagger} &= \int \textrm{d}^{3} \mathbf{k} \phi_{\alpha_i}(\mathbf{k}) a_{k}^{\dagger} \\
	\Rightarrow a_{\mathbf{p}} a_{\alpha_i}^{\dagger} &= \int \textrm{d}^{3} \mathbf{k} \phi_{\alpha_i}(\mathbf{k}) a_{\mathbf{p}} a_{\mathbf{k}}^{\dagger} = \phi_{\alpha_i}(\mathbf{p}) - a_{\alpha_i}^{\dagger} a_{\mathbf{p}}
\end{align}
So,
\begin{align}
	a_{\mathbf{p}} \ket{\Phi} &= a_{\mathbf{p}} a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \ldots a_{\alpha_A}^{\dagger} \ket{0} = (\phi_{\alpha_1}(\mathbf{p}) - a_{\alpha_1}^{\dagger} a_{\mathbf{p}}) a_{\alpha_2}^{\dagger} \ldots a_{\alpha_A}^{\dagger} \ket{0} \\
	&= \sum_{i=1}^{A} (-1)^{i-1} \phi_{\alpha_{i}}(\mathbf{p}) \ket{ \alpha_1 \ldots \alpha_{i-1} \alpha_{i+1} \ldots \alpha_A}
\end{align}
The conjugate gives,
\begin{align}
	\bra{\Phi} a_{\mathbf{p}}^{\dagger} &= \sum_{j=1}^{A} (-1)^{j-1} \bra{ \alpha_1 \ldots \alpha_{j-1} \alpha_{j+1} \ldots \alpha_A} \phi_{\alpha_j}^{\dagger}(\mathbf{p})
\end{align}
Hence,
\begin{align}
\braket{ \Phi | a_{\mathbf{p}}^{\dagger} a_{\mathbf{p}} | \Phi} &= \sum_{i,j=1}^{A} (-1)^{i+j} \phi_{\alpha_j}^{\dagger}(\mathbf{p}) \phi_{\alpha_{i}}(\mathbf{p})  \underbrace{\braket{ \alpha_1 \ldots \alpha_{j-1} \alpha_{j+1} \ldots \alpha_A | \alpha_1 \ldots \alpha_{i-1} \alpha_{i+1} \ldots \alpha_A }}_{=\delta_{ij}} \\
	&= \sum_{i} \phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_{i}}(\mathbf{p})
\end{align}
Which is exactly the same result as before.



So the one body momentum distribution is given by,
\begin{align}
	\braket{ \Phi | \hat{n}(p) | \Phi} &=  \sum_{i=1}^{A} \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}}\phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_i}(\mathbf{p})
\end{align}
Note that this distribution is normed to the number of particles $A$. To get the momentum distribution normed to unity we have to divide by A,
\begin{align}
	\braket{ \Phi | \hat{n}(p) | \Phi} &=  \frac{1}{A} \sum_{i=1}^{A} \frac{1}{(2 \pi)^{3}} \int \textrm{d}^{2} \Omega_{\mathbf{p}}\phi_{\alpha_i}^{\dagger}(\mathbf{p}) \phi_{\alpha_i}(\mathbf{p})
\end{align}

\section{Nucleus}
\subsection{shell.h}
This class contains the quantum number of a shell $nlj$. It has two (proton \& neutron) static arrays containing all the shells.
\begin{verbatim}
	shellsN = [ Shell(n1,l1,j1), Shell(n2,l2,j2), ... ]
	shellsP = [ Shell(n1,l1,j1), Shell(n2,l2,j2), ... ]
\end{verbatim}
These two arrays are initialised and deleted by the static methods \texttt{Shell::initialiseShells}, \texttt{Shell::deleteShells}.

\subsection{nucleus.h}
First important method here is \texttt{Nucleus::makePairs}. Note that this relies on overloaded virtual functions to function. It iterates over the quantum numbers, $n_1 l_1 j_1 m_{j_1}, n_2 l_2 j_2 m_{j_2}$ and makes a pair for each of these combinations: \texttt{Pair::Pair(mosh,n1,l1,j1,mj1,t1,n2,l2,j2,mj2,t2)}. \texttt{mosh} is the return value of \texttt{RecMosh::createRecMosh(n1,l1,n2,l2,inputdir,outputdir)}, being a \texttt{RecMosh} object. The moshinsky brackets $\braket{n_1 l_1 n_2 l_2; \Lambda | n l N L ; \Lambda}$ can be accessed by calling \texttt{RecMosh::getCoefficient(n,l,N,L,Lambda)}.
Open shells are taken care of by calculating a open shell correction factor and applying it to the pair via \texttt{Pair::setfnorm(factor)}.

Once the pairs (\texttt{Pair::Pair}) are generated we can generate a 



\section{Pair coupling}
\subsection{pair.h}
This class represents the state
\begin{align}
	\ket{ \alpha_1, \alpha_2}_{\textrm{nas}} \;\;\;, \ket{\alpha} \equiv \ket{n l j m_j t m_t}
\end{align}
The class calculates all the coefficients,
\begin{align}
	C_{\alpha_1 \alpha_2}^{A} = \braket{A \equiv \{ n l S j m_j, N L M_L T M_T\} | \alpha_1 \alpha_2}
	\label{eq:coef}
\end{align}
The main method here is \texttt{Pair::makecoeflist()}. It loops over all possible values of $ A \equiv \{ S,T,n,l,N,M_L,j,m_j \}$. Where in the summation over $\{n,l,N,L\}$ the energy conservation $2n_1 + l_1 + 2n_2 + l_2 = 2n + l + 2N + L$ is taken into account to eliminate one of the summation loops, $L = 2n_1 + l_1 + 2n_2 + l_2 - 2n - l - 2N$. Note that $M_T$ is also fixed by $M_T = m_{t_1} + m_{t_2}$ and no summation over this is performed, as we want to keep the contribution from different pairs seperated.
For each $A$ a new object \texttt{Newcoef} is generated and stored in the member \texttt{std::vector<NewCoef*> coeflist}.
\subsection{newcoef.h}
This class takes the parameters $n_1 l_1 j_1 m_{j_1} m_{t_1} n_2 l_2 j_2 m_{j_2} m_{t_2} N L M_L n l S j m_j T M_T$, and calculates the coefficient given in Eq. (\ref{eq:coef}). It takes also a pointer to a \texttt{RecMosh} object that holds the Moshinsky brakets. The only function in this class is to calculate $C_{\alpha_1 \alpha_2}^{A}$ using the formula,
\begin{multline}
	\sum_{J M_J} \sum_{\Lambda} 
	[ 1 - (-1)^{L+S+T}] \braket{ t_1 m_{t_1} t_2 m_{t_2} | T M_T }
	\braket{ j_1 m_{j_1} j_2 m_{j_2} | J M_J}
	\braket{ j m_j L M_L | J M_J } \\
	\braket{ n l N L; \Lambda | n_1 l_1 n_2 l_2 ; \Lambda}_{\textrm{SMB}}
	\sqrt{2 \Lambda + 1} \sqrt{ 2j+1}
	\left\{
	\begin{array}{ccc}
		j & L & J \\
		\Lambda & S & l
	\end{array}
	\right\} \\
	\sqrt{2j_1 + 1} \sqrt{2j_2 + 1} \sqrt{ 2S + 1} \sqrt{ 2 \Lambda + 1}
	\left\{
	\begin{array}{ccc}
		l_1 & s_1 & j_1 \\
		l_2 & s_2 & j_2 \\
		\Lambda & S & J \\
	\end{array}
	\right\}
\end{multline}
It is easy to check that the result indeed depends on $\alpha_1, \alpha_2, A$. Note that it is always assumed that $s_i,t_i \equiv \frac{1}{2}$ as we are dealing with protons and neutrons.
This class also defines a \texttt{``key''} to be able to index the coefficients, \texttt{key = ``nlSjm\_j.NLM\_L.TM\_T''}.

\subsection{paircoef.h}
This is a very thin class designed to do some bookkeeping. As outlined in Maartens thesis pg 156, different $\ket{\alpha_1 \alpha_2}$ combinations will sometimes map to the same ``rcm'' states $A = \ket{ nlSjm_j NLM_L TM_T}$. In matrix element calculations,
\begin{align}
	\braket{\alpha_1 \alpha_2 | \hat{\mathcal{O}} | \alpha_1 \alpha_2} = \sum_{AB} C_{\alpha_1 \alpha_2}^{A \dagger} C_{\alpha_1 \alpha_2}^{B} \braket {A | \hat{\mathcal{O}} | B }
	\label{eq:rcm_nonzerodiag}
\end{align}
We want to calculate matrix elements as $\braket{ A | \hat{\mathcal{O}} | B}$ only once. $\ket{\alpha_1 \alpha_2}$ that map to the same $A,B$ states should lookup the earlier calculated values for $\braket{ A | \hat{\mathcal{O}} | B}$.
In general the matrix element $\braket{ A | \hat{\mathcal{O}} | B }$ is not diagonal. 
A \texttt{Paircoef} object has all the quantum numbers in a rcm state $A$. In addition it holds a value and a map \texttt{ std::map<Paircoef*, double>}. The map is used to link a rcm state $\ket{A}$ to all other rcm states $\ket{B}$ which yield a non zero contribution for $\braket{ A | \hat{\mathcal{O}} | B }$. The value for the transformation coefficients $C_{\alpha_1,\alpha_2}^{A,\dagger} C_{\alpha_1,\alpha_2}^{B}$ is stored in the second field of the map (\texttt{double}). So that the the summation over $B$ (Eq. \ref{eq:rcm_nonzerodiag}) is replaced by,
\begin{align}
	\braket{\alpha_1 \alpha_2 | \hat{\mathcal{O}} | \alpha_1 \alpha_2} = \sum_{A} \sum_{\texttt{Paircoef(A).links}}  \texttt{link.strength} \braket {A | \hat{\mathcal{O}} | B }
\end{align}
\todo[inline]{\texttt{Paircoef::add(double val)} adds \texttt{val} to private member \texttt{value} but as far as I can see this private member \texttt{value} is NEVER used!}

\section{Matrix Elements}
\subsection{norm\_ob}
Here we take a look at the calculation of the norm $\mathcal{N}$ in \texttt{norm\_ob.cpp}.
\begin{itemize}
	\item \texttt{norm\_ob::get\_me( Pair )}.
		This calculates the matrix element $\sum_{ A B } C_{\alpha_1 \alpha_2}^{A \dagger} C_{\alpha_1 \alpha_2}^{B} \braket {A | B }$ for a specific pair $\alpha_1 \alpha_2$ passed trough \texttt{Pair}. It is possible to filter on relative quantum numbers on $n_A,l_A,n_B,l_B$, selecting specific contributions \texttt{nAs,lAs,nBs,lBs} to the sum. A value of $-1$ for these variables is interpreted as ``all values allowed''. Trough the braket $\braket{ A | B }$ we already have $n_A = n_B := n$, $l_A = l_B := l$.
		\begin{itemize}
			\item \texttt{if (nAs > -1 \&\& nBs > -1)}
				This forces $\texttt{nAs} = \texttt{nBs} = n$. So for $\texttt{nAs} \neq \texttt{nBs}$ we will get $0$.
			\item \texttt{if (nAs == -1 \&\& nBs > -1)}
				This forces $\texttt{nBs} = n$. Selecting a specific $n = n_A = n_B$ contribution.
			\item \texttt{if (nAs > -1 \&\& nBs == -1)}
				This forces $\texttt{nAs} = n$. Selecting a specific $n = n_A = n_B$ contribution.
			\item \texttt{if (nAs == -1 \&\& nBs == -1)}
				This makes no restrictions on $n = n_A = n_B$.
		\end{itemize}
		The exact same is valid for $l = l_A = l_B$ and \texttt{lAs},\texttt{lBs}.
		A few examples (\texttt{nAs,lAs,nBs,lBs}):
		\begin{itemize}
			\item (\texttt{-1, 2,-1,-1}) : allow all $n = n_A = n_B$ values. Restriction on $l = l_A = l_B = \texttt{2}$.
			\item (\texttt{-1, 2,-1, 2}) : allow all $n = n_A = n_B$ values. Restriction on $l = l_A = l_B = \texttt{2}$.
		\end{itemize}
		Factors $1/2$ you see popping up comes from the fact that if we select a specific contribution for the isospin $t_1$ we have something like $ \sum_{T M_T} \braket{ 1/2 t_1 1/2 t_2 | T M_T } \braket{ T M_T | 1/2 t_1 1/2 t_2}$. If $t_1 \neq t_2$ we have $M_T = 0$ and this is equal to,
		\begin{align}
		&\braket{ 1/2 t_1 1/2 t_2 | 1 0}\braket{1 0 | 1/2 t_1 1/2 t_2} +  \braket{ 1/2 t_1 1/2 t_2 | 0 0}\braket{0 0 | 1/2 t_1 1/2 t_2}\\
		=& \frac{1}{2} \left| \braket{ t_1 t_2 | \uparrow \downarrow + \downarrow \uparrow } \right|^{2} + \frac{1}{2} \left| \braket{ t_1 t_2 | \uparrow \downarrow - \downarrow \uparrow } \right|^{2} 
		\end{align}
		However due to antisymmetry of the wave function $ L + S + T = -1 $ ( or something like that (I need to look up exact quantum numbers there). We have that one of these terms will be zero and we get a factor $1/2$ if we choose a specific $t_1,t_2$ combination, $\uparrow \downarrow$ or $\downarrow \uparrow$.
		
\end{itemize}
\end{document}
